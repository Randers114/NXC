#include "RobotMoves.h"

#define CENTER_SQUARE -125
#define FIRST_EDGE_SQUARE 35
#define EDGE_SQUARE -20
#define CORNER_SQUARE 20

void ResetColorSensor()
{
     // Resets the position of the color sensor.
     OnFwd(OUT_A, 30);
     Wait(2000);
     Off(OUT_A);
     Wait(500);
}

char ColorRead(int x)
{
     // Places the color sensor, reads the color of a given sub-square, and returns the color.
     unsigned int rawData[];
     char tempColour;
     RotateMotorPID(OUT_A, 40, x, 20, 40, 100);
     Wait(100);
     SetSensor(S4, _SENSOR_CFG(SENSOR_TYPE_COLORFULL, SENSOR_MODE_RAW));
     ReadSensorColorRaw(S4, rawData);


     // Red 
     if((rawData[0] >= 505 && rawData[0] <= 519) && (rawData[1] >= 234 && rawData[1] <= 254) && (rawData[2] >= 187 && rawData[2] <= 199) )
     {
        tempColour = 'r';
     }
     // Orange 
     else if ((rawData[0] >= 529 && rawData[0] <= 541) && (rawData[1] >= 269 && rawData[1] <= 281) && (rawData[2] >= 188 && rawData[2] <= 198) )
     {
       tempColour = 'o';
     }
     // Green 
     else if ((rawData[0] >= 303 && rawData[0] <= 325) && (rawData[1] >= 333 && rawData[1] <= 347) && (rawData[2] >= 234 && rawData[2] <= 248) )
     {
        tempColour = 'g';
     }
     // Blue 
     else if ((rawData[0] >= 278 && rawData[0] <= 292) && (rawData[1] >= 259 && rawData[1] <= 272) && (rawData[2] >= 313 && rawData[2] <= 326) )
     {
        tempColour = 'b';
     }
     // Yellow
     else if ((rawData[0] >= 545 && rawData[0] <= 559) && (rawData[1] >= 426 && rawData[1] <= 438) && (rawData[2] >= 321 && rawData[2] <= 334) )
     {
        tempColour = 'y';
     }
     // White
     else
     {
        tempColour = 'w';
     }

     return tempColour;
}

int MapColourPlacement(int placement)
{
    // Switches on the sequence that the color-sensor reads the sub-squares, without the center-piece and the first edge-piece.
    // Returns the matching placement in the representation. 
    int tempPlacement = 0; 
    switch(placement)
    {
      case 0: 
        tempPlacement = 6;
        break;
      
      case 1: 
        tempPlacement = 3;
        break;

      case 2: 
        tempPlacement = 0;
        break;

      case 3: 
        tempPlacement = 1;
        break;

      case 4: 
        tempPlacement = 2;
        break;      

      case 5: 
        tempPlacement = 5;
        break;

      case 6: 
        tempPlacement = 8;
        break;      

      default:
        break;
    }

    return tempPlacement;
}

void ColorReadFace(int face)
{
    char tempFace[9];

    tempFace[4] = ColorRead(CENTER_SQUARE);
    tempFace[7] = ColorRead(FIRST_EDGE_SQUARE);

    int counter = 0;
    for(int i = 0; i < 3; i++) {
       TurnCube(45);
       tempFace[MapColourPlacement(counter)] = ColorRead(CORNER_SQUARE);
       counter++;

       TurnCube(45);
       tempFace[MapColourPlacement(counter)] = ColorRead(EDGE_SQUARE);
       counter++;

       //PlaceCube();
    }

    TurnCube(45);
    tempFace[MapColourPlacement(counter)] = ColorRead(CORNER_SQUARE);

    TurnCube(45);

 //  InitializeSide(tempFace, face);
}

int MapFace(int placement)
{
    // Returns the face in the representation that corresponds to the current face in the sequence of reading the colors.
    int tempPlacement = 0;
    switch(placement)
    {
      case 0: 
        tempPlacement = 0;
        break;

      case 1: 
        tempPlacement = 2;
        break;

      case 2: 
        tempPlacement = 5;
        break;

      case 3: 
        tempPlacement = 3;
        break;      

      case 4: 
        tempPlacement = 4;
        break;      

      case 5: 
        tempPlacement = 1;
        break;      

      default:
        break;
    }

    return tempPlacement;
}

void ReadLeftThenRight()
{
  // Left face
  ResetColorSensor();
  TurnCube(90);
  FlipCube(1);
  UnlockCube();
  ColorReadFace(4);

  //Right face
  ResetColorSensor();
  FlipCube(2);
  UnlockCube();
  ColorReadFace(5);

  //Reset cube for solving
  ResetColorSensor();
  FlipCube(1);
  UnlockCube();
  TurnCube(270);
}

void ReadCubeColors()
{
    ResetColorSensor();
    AlignCubeLayers();
    UnlockCube();
   
    for (int i = 0; i < 4; i++)
    {
        ColorReadFace(MapFace(i));
        ResetColorSensor();
        FlipCube(1);
        UnlockCube();
    }

    ReadLeftThenRight();

   
    //NumOut(0, LCD_LINE1, result);
    Wait(5000);
}

task main()
{
    ReadCubeColors();
   
  //  CubeCheck();
}
