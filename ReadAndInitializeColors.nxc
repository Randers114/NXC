#include "WhiteCross.h"


#define CENTER_SQUARE -125
#define FIRST_EDGE_SQAURE 35
#define EDGE_SQUARE -20
#define CORNER_SQUARE 20

void ResetColorSensor(){
      OnFwd(OUT_A, 30);
      Wait(2000);
      Off(OUT_A);
      Wait(500);
}

void PlaceCube() {
    RotateMotorPID(OUT_B, 30, -140, 20, 40, 100);
    Wait(300);
    RotateMotorPID(OUT_B, 30, 140, 20, 40, 100);
}

char ColorRead(int x){
     unsigned int rawData[];
     char tempColour;
     RotateMotor(OUT_A, 40, x);
     Wait(300);
     SetSensor(S1,  _SENSOR_CFG(SENSOR_TYPE_COLORFULL, SENSOR_MODE_RAW));


     // Red 
     if((rawData[0] >= 505 && rawData[0] <= 519) && (rawData[1] >= 234 && rawData[1] <= 254) && (rawData[2] >= 187 && rawData[2] <= 199) )
     {
        tempColour = 'r';
     }
     // Orange 
     else if ((rawData[0] >= 529 && rawData[0] <= 541) && (rawData[1] >= 269 && rawData[1] <= 281) && (rawData[2] >= 188 && rawData[2] <= 198) )
     {
       tempColour = 'o';
     }
     // Green 
     else if ((rawData[0] >= 303 && rawData[0] <= 325) && (rawData[1] >= 333 && rawData[1] <= 347) && (rawData[2] >= 234 && rawData[2] <= 248) )
     {
        tempColour = 'g';
     }
     // Blue 
     else if ((rawData[0] >= 278 && rawData[0] <= 292) && (rawData[1] >= 259 && rawData[1] <= 272) && (rawData[2] >= 313 && rawData[2] <= 326) )
     {
        tempColour = 'b';
     }
     // Yellow
     else if ((rawData[0] >= 545 && rawData[0] <= 559) && (rawData[1] >= 426 && rawData[1] <= 438) && (rawData[2] >= 321 && rawData[2] <= 334) )
     {
        tempColour = 'y';
     }
     // White
     else
     {
        tempColour = 'w';
     }

     return tempColour;
}

int MapColour(int placement)
{
    int tempPlacement = 0; 
    switch(placement)
    {
      case 0: 
        tempPlacement = 6;
        
        break;
      
      case 1: 
        tempPlacement = 3;
        
        break;
      case 2: 
        tempPlacement = 0;

        break;
      case 3: 
        tempPlacement = 1;

        break;      
      case 4: 
        tempPlacement = 2;

        break;      
      case 5: 
        tempPlacement = 5;

        break;
      case 6: 
        tempPlacement = 8;

        break;      
      default:
        break;
    }

    return tempPlacement;
}


void ColorReadSide(int face){
   char tempFace[9];

   tempFace[4] = ColorRead(CENTER_SQUARE);
   tempFace[7] = ColorRead(FIRST_EDGE_SQAURE);

   int counter = 0;
   for(int i = 0; i < 4; i++) {
       TurnCube(45);
       tempFace[MapColour(counter)] = ColorRead(CORNER_SQUARE);
       counter++;

       TurnCube(45);
       tempFace[MapColour(counter)] = ColorRead(EDGE_SQUARE);
       counter++;

       PlaceCube();
   }

   InitializeSide(tempFace, face);
}

int MapFace(int placement){
  int tempPlacement = 0;
  switch(placement)
  {
    case 0: 
      tempPlacement = 0;
      
      break;
    case 1: 
      tempPlacement = 2;
      
      break;
    case 2: 
      tempPlacement = 5;

      break;
    case 3: 
      tempPlacement = 3;

      break;      
    case 4: 
      tempPlacement = 4;

      break;      
    case 5: 
      tempPlacement = 1;

      break;      
    default:
      break;
  }

    return tempPlacement;
}


void ReadLeftThenRight(){
  // Left face
  ResetColorSensor();
  PlaceCube();
  TurnCube(90);
  ClawPull();

  //Right face
  ColorReadSide(4);
  ResetColorSensor();
  PlaceCube();
  DoubleClaw();
  ColorReadSide(5);

  //Reset cube for solving
  ResetColorSensor();
  ClawPull();
  TripleTurn();
}

task main()
{
   for (int i = 0; i < 4; i++)
   {
     ResetColorSensor();
     PlaceCube();
     ColorReadSide(MapFace(i));
     ClawPull();
   }

   ReadLeftThenRight();

   
   //NumOut(0, LCD_LINE1, result);
   Wait(5000);
   
   CubeCheck();

}
